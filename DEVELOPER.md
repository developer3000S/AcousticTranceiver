# Техническое описание проекта: Акустический текстовый трансивер

## 1. Обзор и стек технологий

Этот документ предоставляет техническое описание проекта "Акустический текстовый трансивер". Приложение предназначено для передачи текстовых данных с использованием звуковых сигналов (частотная манипуляция) через аналоговый аудиоканал, такой как телефонный звонок.

**Основной стек технологий:**

*   **Фреймворк:** React 18
*   **Язык:** TypeScript
*   **Сборщик:** Vite
*   **Стилизация:** Tailwind CSS
*   **Аудио:** Web Audio API
*   **Тестирование:** Vitest, JSDOM
*   **Сборка для мобильных устройств:** Capacitor

---
## 2. Архитектура и структура проекта

Проект имеет компонентную архитектуру, основанную на React, с четким разделением логики на компоненты (UI), хуки (state management и бизнес-логика) и сервисы (вспомогательные функции).

```
src/
├── App.tsx                     # Главный компонент приложения, компоновка UI
├── components/
│   ├── Sender.tsx              # UI и логика для отправки сообщений
│   ├── Receiver.tsx            # UI и логика для приема сообщений
│   ├── LogPanel.tsx            # UI для отображения журнала событий
│   ├── FrequencyVisualizer.tsx # Визуализация спектра входящего аудио
│   └── TransmissionVisualizer.tsx# Визуализация исходящего сигнала
├── hooks/
│   └── useAudioProcessor.ts    # Хук для обработки аудиопотока и декодирования
├── services/
│   ├── audioService.ts         # Генерация и воспроизведение аудио, создание WAV
│   ├── logger.ts               # Сервис для логирования событий
│   └── soundService.ts         # Сервис для воспроизведения UI-звуков
├── constants.ts                # Глобальные константы, протоколы, карты частот
├── index.css                   # Стили Tailwind CSS
└── index.tsx                   # Точка входа в приложение
```

---
## 3. Ключевые концепции

### 3.1. Протокол передачи данных

Передача данных основана на принципе **частотной манипуляции (Frequency-Shift Keying, FSK)**. Каждому поддерживаемому символу сопоставляется уникальная звуковая частота.

**Структура пакета:**

Каждое сообщение инкапсулируется в пакет для надежного распознавания начала и конца передачи, а также для проверки целостности данных.

1.  **Стартовый сигнал (`<<START>>`):** Специальная частота, сигнализирующая о начале передачи.
2.  **Полезная нагрузка (Payload):** Последовательность тонов, соответствующая символам исходного сообщения.
3.  **Контрольная сумма (Checksum):** Один символ, вычисленный на основе полезной нагрузки. Используется для проверки целостности принятых данных.
4.  **Стоповый сигнал (`<<STOP>>`):** Специальная частота, сигнализирующая о конце передачи.

### 3.2. Профили передачи (Протоколы)

В `constants.ts` определены несколько профилей (`Protocol`) для гибкой настройки передачи:

*   **`standard`:** Сбалансированные настройки.
*   **`fast`:** Уменьшенные паузы для более быстрой передачи.
*   **`reliable`:** Увеличенная длительность тонов и двойная отправка каждого символа для повышения помехоустойчивости.
*   **`quiet`:** Использует диапазон высоких частот (8-13 кГц), которые менее заметны для человеческого слуха и могут лучше проходить через аудиокодеки некоторых мессенджеров.

Каждый протокол определяет `toneDuration`, `pauseDuration` и `charToFreqMap`.

### 3.3. Контрольная сумма

Для верификации данных используется простая, но эффективная контрольная сумма, основанная на операции `XOR` кодов символов сообщения. Результат по модулю приводится к индексу в массиве `CHECKSUM_CHAR_CANDIDATES`, что гарантирует, что сам символ контрольной суммы всегда может быть передан.

---
## 4. Глубокое погружение в компоненты и сервисы

### 4.1. `audioService.ts` (Сервис аудио)

Отвечает за всю логику, связанную с генерацией звука.

*   `playMessage`: Асинхронно воспроизводит сообщение в реальном времени. Использует `AudioContext` для создания и управления `OscillatorNode` (генератор тона) и `GainNode` (управление громкостью). Последовательно проигрывает тоны для стартового сигнала, полезной нагрузки, контрольной суммы и стопового сигнала.
*   `generateMessageWav`: Использует `OfflineAudioContext` для рендеринга аудиосигнала в `AudioBuffer` без его воспроизведения. Это позволяет быстро сгенерировать аудиоданные, которые затем упаковываются в `.wav` файл с помощью вспомогательной функции `bufferToWav`.
*   `calculateChecksum`: Реализует логику вычисления контрольной суммы.

### 4.2. `useAudioProcessor.ts` (Хук обработки аудио)

Это ядро логики получателя. Он инкапсулирует работу с микрофоном и декодирование сигнала.

*   **Инициализация:** При вызове `startListening` запрашивает доступ к микрофону (`navigator.mediaDevices.getUserMedia`) и создает `AudioContext`.
*   **Анализ сигнала:**
    1.  Создается `AnalyserNode` для получения данных о частотном спектре аудиопотока.
    2.  В цикле `requestAnimationFrame` (`analysisLoop`) постоянно вызывается `analyser.getByteFrequencyData()`, которая заполняет `Uint8Array` данными об амплитуде для каждого частотного "бина".
*   **Автоматическая регулировка усиления (АРУ / AGC):**
    *   Хук не использует фиксированный порог для обнаружения сигнала. Вместо этого он динамически вычисляет уровень окружающего шума (`ambientNoiseLevelRef`).
    *   Порог обнаружения (`currentThreshold`) устанавливается как уровень шума плюс некоторый отступ (`AGC_THRESHOLD_OFFSET`), но ограничивается минимальным и максимальным значениями. Это позволяет надежно принимать сигналы разной громкости и в разных шумовых условиях.
*   **Декодирование:**
    1.  Если максимальная амплитуда в спектре превышает текущий порог, определяется частота с пиковой амплитудой.
    2.  Эта частота сопоставляется с символом с помощью `MASTER_FREQ_TO_CHAR_MAP`.
    3.  Используется "debounce"-механизм (`DECODE_DEBOUNCE_MS`), чтобы один и тот же тон не был декодирован несколько раз.
*   **Протокольная стейт-машина:**
    *   Хук отслеживает состояние приема (`isReceivingRef`).
    *   Когда обнаруживается `START_CHAR`, стейт-машина переходит в режим приема, и все последующие символы добавляются во временный буфер.
    *   Когда обнаруживается `STOP_CHAR`, прием завершается. Содержимое буфера проверяется с помощью контрольной суммы, и результат (успех или ошибка) добавляется в список принятых сообщений.

### 4.3. `Sender.tsx`

Компонент-отправитель.

*   Управляет состоянием вводимого сообщения, выбранного шаблона и настроек передачи (протокол, громкость, пауза).
*   Визуализирует неподдерживаемые символы, проверяя их наличие в `charToFreqMap` текущего протокола.
*   Вызывает `playMessage` или `generateMessageWav` из `audioService` для выполнения соответствующих действий.
*   Передает текущую воспроизводимую частоту в `TransmissionVisualizer` для обратной связи в реальном времени.

### 4.4. `Receiver.tsx`

Компонент-получатель.

*   Использует хук `useAudioProcessor` для управления состоянием прослушивания и получения декодированных данных.
*   Отображает список принятых сообщений, помечая их как успешные или ошибочные (в случае несовпадения контрольной суммы).
*   Передает данные о частотном спектре (`frequencyData`) и реальную частоту дискретизации (`sampleRate`) в компонент `FrequencyVisualizer`.

### 4.5. `constants.ts`

Центральный файл конфигурации.

*   `RECEIVER_CONFIG`: Инкапсулирует все настройки, связанные с работой приемника (размер FFT, пороги, параметры АРУ). Это позволяет легко настраивать поведение декодера.
*   `PROTOCOLS`: Объект, содержащий конфигурации для каждого протокола передачи. Это делает систему легко расширяемой — для добавления нового протокола достаточно добавить новый объект в эту структуру.
*   Карты частот:
    *   `CHAR_TO_FREQ_MAP_STD` и `CHAR_TO_FREQ_MAP_QUIET`: Карты для стандартного и "тихого" протоколов.
    *   `MASTER_FREQ_TO_CHAR_MAP`: Объединенная карта (инвертированная), используемая приемником для декодирования любого из поддерживаемых протоколов.

---
## 5. Тестирование

Проект использует **Vitest** для unit-тестирования.

*   **Расположение тестов:** Тесты находятся рядом с тестируемыми модулями (например, `audioService.test.ts`).
*   **Окружение:** Тесты выполняются в окружении `jsdom`.
*   **Мокирование:** Так как Web Audio API недоступна в `jsdom`, создан файл `src/setupTests.ts`, который мокирует `AudioContext` и `OfflineAudioContext`. Это позволяет тестировать логику, зависящую от этих API, без сбоев.
*   **Покрытие:** Тестами покрыта критически важная бизнес-логика, такая как вычисление контрольной суммы и процесс генерации WAV-файла в `audioService`.

---
## 6. Сборка и развертывание

Проект настроен для сборки в нативное Android-приложение с помощью **Capacitor**. Подробные инструкции находятся в файле `INSTALL.md`. Основные шаги включают сборку веб-приложения (`npm run build`), синхронизацию с нативным проектом (`npx cap sync`) и открытие в Android Studio для сборки APK.
